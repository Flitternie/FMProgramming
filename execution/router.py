import ast
import inspect
import astor
import functools
from execution.image_patch import ImagePatch, distance
from routing import Router, StructuredRouter

routing_options = {
    'find': [17, 23],
    'exists': [17, 23],
    'verify_property': [182, 3770],
    'query': [182, 3770]
}

tracked_methods = ["find", "exists", "verify_property", "query"]
tracked_functions = ["llm"] 

# Dictionary to store counts separately for method names and routing argument values
method_call_tracker = {}
function_call_tracker = {}
execution_trace = set()  # Stores (method_name, query) tuples

def count_method_calls(func):
    """Decorator to count method calls separately based on method name and routing argument."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        global method_call_tracker, execution_trace
        method_name = func.__name__  # Get the method name
        routing_value = kwargs.get("routing", None)  # Get 'routing' arg if available

        query = ", ".join([arg for arg in args if isinstance(arg, str)])

        # Create key for counting (method_name, routing_value)
        key = (method_name, routing_value)

        # Initialize or increment the counter for this method-routing combination
        method_call_tracker[key] = method_call_tracker.get(key, 0) + 1

        # Store executed queries for verification
        if query:
            execution_trace.add(f'''{method_name}('{query}')''')

        return func(*args, **kwargs)

    return wrapper

def count_function_calls(func):
    """Decorator to count function calls separately based on function name."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        global function_call_tracker
        function_name = func.__name__
        routing_value = kwargs.get("routing", None)  # Get 'routing' arg if available

        query = ", ".join([arg for arg in args if isinstance(arg, str)])

        key = (function_name, routing_value)

        # Initialize or increment function call counter
        function_call_tracker[key] = function_call_tracker.get(function_name, 0) + 1

        # Store executed queries for verification
        if query:
            execution_trace.add(f'''{function_name}('{query}')''')

        return func(*args, **kwargs)

    return wrapper

def wrap_specific_methods(cls, method_names):
    """
    Wrap only specific methods in a class with the method call counter decorator.

    Args:
        cls: The class whose methods should be wrapped.
        method_names: List of method names to wrap.
    """
    for method_name in method_names:
        if hasattr(cls, method_name):  # Ensure the method exists
            original_method = getattr(cls, method_name)
            if callable(original_method):  # Only wrap callable methods
                setattr(cls, method_name, count_method_calls(original_method))

def wrap_specific_functions(function_list):
    """
    Wrap specific standalone functions with the function call counter decorator.

    Args:
        function_list: List of function objects to wrap.
    """
    for func in function_list:
        if callable(func):
            setattr(func.__globals__, func.__name__, count_function_calls(func))


def execute_routed_program(routed_program, image):
    """
    Executes the routed program, prints method & function call statistics, 
    checks for a specific method + query combination, and resets counters.

    Args:
        routed_program: The routed function generated by RoutingSystem.
        image: The input image for processing.
        specific_check: Tuple (method_name, query) to verify if it was executed.
    """
    global method_call_tracker, function_call_tracker, execution_trace

    # Reset counters before execution
    method_call_tracker.clear()
    function_call_tracker.clear()
    execution_trace.clear()

    # Execute the routed program
    output = routed_program(image)

    execution_counter = []

    # Print results after execution
    for (method_name, routing_value), count in method_call_tracker.items():
        execution_counter.append((method_name, routing_value, count))

    for (function_name, routing_value), count in function_call_tracker.items():
        execution_counter.append((function_name, routing_value, count))
    
    return output, execution_counter, execution_trace


def check_execution(execution_trace, function_calls):
    """
    Check if a specific method + query combination was executed during the program run.

    Args:
        execution_trace: Set of executed method + query combinations.
        function_calls: List of method + query combinations to check.
    """
    execution_flag = []
    for function_call in function_calls:
        if function_call in execution_trace:
            execution_flag.append(1)
        else:
            execution_flag.append(0)
    return execution_flag

def execution_cost(execution_counter):
    """
    Calculate the execution cost based on the execution statistics.

    Args:
        execution_counter: List of tuples (method_name/function_name, routing_value, count).
    """
    cost = 0
    for function, routing, count in execution_counter:
        if routing is not None:
            cost += count * routing_options[function][routing]
    return cost

# Apply the decorator to specific methods in ImagePatch
wrap_specific_methods(ImagePatch, tracked_methods)
# Apply the decorator to specific standalone functions
wrap_specific_functions(tracked_functions)


class RoutingSystem:
    def __init__(self, func, source, cost_weighting, struct=True):
        '''
        This class initializes the routing system for the user program.

        Args:
            func: Function to execute the user program
            source: Source code of the user program
            cost_weighting: Cost weighting parameter for the router

        Methods:
            initialize: Initializes the routing decisions based on the function calls in the user program
            make_routing_decisions: Makes routing decisions based on the input image
            routing: Modifies the AST of the user program to add routing arguments
            update_router: Updates the router based on the reward received
            analyze_user_program: Extracts the method calls and queries from a user program
        
        '''
        self.func = func
        self.source = source
        self.cost_weighting = cost_weighting
        self.function_calls = self.analyze_user_program()
        self.initialize(self.function_calls, struct)
    
    def initialize(self, function_calls, struct):
        # Initialize routing decisions based on function calls in the user program
        '''
        This function initializes the routing decisions based on the function calls in the user program.

        Args:
            function_calls: List of dictionaries containing the function calls and queries

        '''
        self.routing_info = {call['identifier']: 0 for call in function_calls}  # Default routing to 0 (small model)
        if struct:
            self.router = StructuredRouter(self.routing_info, routing_options, self.cost_weighting)
        else:
            self.router = Router(self.routing_info, routing_options, self.cost_weighting)
    
    def make_routing_decisions(self, input_image) -> dict:
        '''
        This function makes routing decisions based on the input image.

        Args:
            input_image: ImagePatch object
        
        Returns:
            routing_decisions: Dictionary containing the routing decisions for each function call
            idx: Index of the arm or the group of arms selected by the router

        '''
        routing_decisions, idx = self.router.select(input_image)
        return routing_decisions, idx

    def routing(self, input, config=None, display=False):
        '''
        This function modifies the AST of the user program to add routing arguments.

        Args:
            input: ImagePatch object
            config: None for dynamic routing, or 0 for static routing with the smallest model configuration, or 1 for the largest model configuration
            display: Boolean to display the modified AST

        Returns:
            execute_command: Function to execute the modified user program
            routing_decisions: Dictionary containing the routing decisions for each function call
            idx: Index of the arm selected by the router
        
        '''
        tree = ast.parse(self.source)
        if config is not None:
            assert config in [0, 1], "Invalid configuration"
            routing_decision = -1 if config == 1 else 0
            routing_decisions = {key: routing_decision for key in self.routing_info.keys()}
            idx = self.router.num_arms - 1 if config == 1 else 0
        else:
            routing_decisions, idx = self.make_routing_decisions(input)

        class RoutingArgumentTransformer(ast.NodeTransformer):
            def visit_Call(self, node):
                if isinstance(node.func, ast.Attribute) and isinstance(node.func.value, ast.Name):
                    instance_name = node.func.value.id
                    method_name = node.func.attr
                
                    if method_name in routing_options.keys():
                        # Generate an identifier to match against routing info
                        if len(node.args) > 0:
                            query = ", ".join([arg.s for arg in node.args if isinstance(arg, ast.Str)])
                            identifier = f"{method_name}('{query}')"
                            routing_value = int(routing_decisions[identifier])

                            # Add the routing argument to the function call
                            node.keywords.append(ast.keyword(arg='routing', value=ast.Constant(value=routing_value)))

                return self.generic_visit(node)

        transformer = RoutingArgumentTransformer()
        modified_tree = transformer.visit(tree)
        if display:
            print(astor.to_source(modified_tree))
        ast.fix_missing_locations(modified_tree)
        compiled_code = compile(modified_tree, filename="<ast>", mode="exec")

        # Adding imports and necessary globals to ensure everything is available during execution
        exec_globals = {
            '__builtins__': __builtins__,  # Provide access to built-ins
            'ImagePatch': ImagePatch,      # Ensure ImagePatch is available during execution
            'distance': distance,          # Ensure distance function is available during execution
        }
        exec(compiled_code, exec_globals)
        execute_command = exec_globals['execute_command']

        return execute_command, routing_decisions, idx

    def update_router(self, input_image, routing_idx, reward, reward_mapping=None):
        '''
        This function updates the router based on the reward received.

        Args:
            input_image: ImagePatch object
            routing_idx: Index of the arm selected by the router
            reward: Reward received
            reward_mapping: Mapping of rewards to specific subrewards
        
        '''
        self.router.update(input_image, routing_idx, reward, reward_mapping)

    def analyze_user_program(self):
        '''
        This function extracts the method calls and queries from a user program.

        Returns:
            function_calls: List of dictionaries containing the function calls and queries

        '''
        self.source = inspect.getsource(self.source) if not isinstance(self.source, str) else self.source
        tree = ast.parse(self.source)
        function_calls = []

        class MethodCallVisitor(ast.NodeVisitor):
            def visit_Call(self, node):
                if isinstance(node.func, ast.Attribute):
                    # Extract the function call details
                    method_name = node.func.attr
                    instance_name = node.func.value.id if isinstance(node.func.value, ast.Name) else None
                    # Get arguments, specifically for calls like find, vqa, etc.
                    if method_name in routing_options.keys():
                        if len(node.args) > 0:
                            query = ", ".join([arg.s for arg in node.args if isinstance(arg, ast.Str)])
                            identifier = f"{method_name}('{query}')"
                            function_calls.append({
                                'method_name': method_name,
                                'query': query,
                                'identifier': identifier
                            })
                self.generic_visit(node)

        MethodCallVisitor().visit(tree)
        return function_calls